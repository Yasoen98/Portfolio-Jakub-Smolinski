<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Panel Użytkownika - Pokoje</title>
<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
<style>
/* Podświetlenie (tak jak w admin) */
.room-card .guest-inline {
  display:block;
  margin-top:6px;
  font-size:13px;
  background:rgba(255,255,255,.25);
  padding:4px 8px;
  border-radius:8px;
}
.hidden { display:none !important; }
.small { font-size:12px; opacity:.8; }
</style>
</head>
<body>
<div class="container">
    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="top-section menu-buttons">
                <button onclick="showSection('rooms')" class="active">Lista Pokoi</button>
                <button onclick="showSection('tickets')">Zgłoszenia</button>
            </div>
            <div class="bottom-section">
                <button onclick="logout()">Wyloguj</button>
            </div>
        </div>

        <!-- Content -->
        <div class="content">
            <!-- Lista Pokoi -->
            <div id="rooms" class="section">
                <h2>Lista Pokoi</h2>
                <div id="roomsGrid" class="room-grid"></div>
                <div id="roomsPagination" class="pagination"></div>
            </div>

            <!-- Zgłoszenia -->
            <div id="tickets" class="section" style="display:none;">
                <h2>Zgłoszenia</h2>

                <!-- Toolbar jak w adminie -->
                <div class="list-toolbar" style="margin:8px 0;">
                  <input id="ticketSearch" placeholder="Szukaj po pokoju, statusie lub treści..." oninput="applyTicketFilter()">
                </div>

                <!-- Toggle formularza zgłoszenia -->
                <button id="toggleTicketForm" style="margin-bottom: 12px;">Pokaż formularz zgłoszenia</button>
                <div id="ticketFormContainer" style="display:none;">
                    <form id="ticketForm">
                        <label>Pokój:</label>
                        <select id="ticketRoom"></select>
                        <label>Powód zgłoszenia:</label>
                        <select id="ticketReason">
                            <option value="brudny pokój">Brudny pokój</option>
                            <option value="problem z urządzeniem">Problem z urządzeniem</option>
                            <option value="inne">Inne</option>
                        </select>
                        <input type="text" id="ticketMessage" placeholder="Dodatkowa wiadomość...">
                        <button type="button" onclick="sendTicket()">Wyślij zgłoszenie</button>
                    </form>
                </div>

                <!-- Tabela jak w adminie -->
                <table id="ticketsTable" class="styled-table" style="margin-top:10px;">
                  <thead>
                    <tr>
                      <th>Nr. Pokoju</th>
                      <th>Status</th>
                      <th>Data</th>
                      <th>Powód</th>
                      <th>Akcje</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
                <div id="ticketsPagination" class="pagination"></div>

                <!-- Kontener na wielookienne czaty -->
                <div id="activeChats" class="chat-container" style="margin-top:14px;"></div>
            </div>
        </div>
    </div>
</div>

<!-- Guzik trybu sprzątania z badge -->
<div class="btn-with-badge">
  <button id="editToggle" title="Tryb sprzątania">🧹</button>
  <span id="dirtyBadge" class="badge-dot hidden" title="Brudne pokoje">0</span>
</div>

<div id="toast"></div>

<script>
let currentRoomPage = 1;
const roomsPerPage = 12;
let allRooms = [];
let editMode = false; // tryb sprzątania (filtr: tylko 'dirty')
let currentUsername = null;

/* Tickets (jak w adminie) */
let allTickets = [];
let currentTicketPage = 1;
const ticketsPerPage = 10;
let ticketSearchTerm = "";

/* ---- user ---- */
async function loadCurrentUser(){
    const res = await fetch('/api/me');
    if(res.ok){
        const data = await res.json();
        currentUsername = data.username;
    }
}

/* ---- sidebar ---- */
function showSection(sectionId){
    document.querySelectorAll('.section').forEach(s=>s.style.display='none');
    document.getElementById(sectionId).style.display='block';
    document.querySelectorAll('.menu-buttons button').forEach(b=>b.classList.remove('active'));
    event.target.classList.add('active');

    if(sectionId === 'tickets'){
      loadTickets(); // odśwież listę przy wejściu
    }
}

function showToast(msg){
    const toast = document.getElementById('toast');
    toast.textContent = msg;
    toast.className = 'show';
    setTimeout(()=>{ toast.className=''; },3000);
}

function logout(){
    fetch('/logout').then(()=>window.location.href='/');
}

/* ---- rooms ---- */
async function loadRooms(){
    const res = await fetch('/api/rooms');
    if(res.status===401){ window.location.href='/'; return; }
    allRooms = await res.json();
    // sort wg numeru
    allRooms.sort((a,b)=>parseInt(a.number)-parseInt(b.number));
    renderRooms(currentRoomPage);
    await updateDirtyBadge();
}

function renderRooms(page=1){
    currentRoomPage = page;
    // w trybie sprzątania pokazuj tylko brudne
    let filtered = allRooms.filter(r => editMode ? r.status==='dirty' : true);

    const start = (page-1)*roomsPerPage;
    const end = start + roomsPerPage;
    const rooms = filtered.slice(start,end);

    const grid = document.getElementById('roomsGrid');
    grid.innerHTML = '';
    rooms.forEach(r=>{
        const state = r.status==='occupied' ? 'room-occupied' : r.status==='clean' ? 'room-clean' : 'room-dirty';
        const card = document.createElement('div');
        card.className = `room-card ${state} ${editMode ? 'editable' : ''}`;

        // NIE wyświetlamy gościa (pkt 2)
        // Podświetlony komentarz (pkt 1)
        const commentLine = r.comment
          ? `<div class="guest-inline">Komentarz: ${r.comment}</div>` : '';

        card.innerHTML = `
            <h3>${r.priority==1 ? '⚠️ Pokój '+r.number+' ⚠️' : 'Pokój '+r.number}</h3>
            <p>Typ: ${r.type}</p>
            ${commentLine}
            <select onchange="changeStatus(${r.id}, this.value)" ${r.status==='occupied' ? 'disabled' : ''}>
                <option value="clean" ${r.status==='clean'?'selected':''}>Clean</option>
                <option value="dirty" ${r.status==='dirty'?'selected':''}>Dirty</option>
                <option value="occupied" disabled ${r.status==='occupied'?'selected':''}>Occupied</option>
            </select>
        `;
        grid.appendChild(card);
    });

    // Paginacja
    const pagination = document.getElementById('roomsPagination');
    pagination.innerHTML='';
    const totalPages = Math.ceil(filtered.length/roomsPerPage);
    for(let i=1;i<=totalPages;i++){
        const btn = document.createElement('button');
        btn.textContent = i;
        btn.className = i===currentRoomPage ? 'pageBtn active' : 'pageBtn';
        btn.onclick = ()=>renderRooms(i);
        pagination.appendChild(btn);
    }
}

async function changeStatus(id, newStatus){
    const res = await fetch(`/api/room/${id}`, {
        method:'PUT',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({status: newStatus})
    });
    if(res.ok){
        showToast('Zmieniono status pokoju!');
        await loadRooms();
        await updateDirtyBadge();   // przelicz badge po zmianie
    } else {
        const data = await res.json().catch(()=>({}));
        showToast(data.error || 'Błąd!');
    }
}

document.getElementById('editToggle').addEventListener('click', ()=>{
    editMode = !editMode;
    renderRooms(1);
});

/* ---- zgłoszenia: UI ---- */
document.getElementById('toggleTicketForm').addEventListener('click', () => {
    const container = document.getElementById('ticketFormContainer');
    const btn = document.getElementById('toggleTicketForm');
    const show = (container.style.display === 'none' || container.style.display === '');
    container.style.display = show ? 'block' : 'none';
    btn.textContent = show ? 'Ukryj formularz zgłoszenia' : 'Pokaż formularz zgłoszenia';
});

/* ---- zgłoszenia: dane + tabela jak w adminie ---- */
async function loadRoomsForTicket(){
    const res = await fetch('/api/rooms');
    if(!res.ok) return;
    const rooms = await res.json();
    const sel = document.getElementById('ticketRoom');
    sel.innerHTML='';
    rooms.forEach(r=>{
        sel.innerHTML += `<option value="${r.id}">${r.number}</option>`;
    });
}

async function sendTicket(){
    const room_id = document.getElementById('ticketRoom').value;
    const reason = document.getElementById('ticketReason').value;
    const msg = document.getElementById('ticketMessage').value || reason;

    const res = await fetch('/api/tickets', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({room_id, reason: msg})
    });
    if(res.ok){ showToast('Zgłoszenie wysłane!'); loadTickets(); }
    else { showToast('Błąd przy wysyłaniu zgłoszenia'); }
}

function applyTicketFilter(){
  ticketSearchTerm = (document.getElementById('ticketSearch').value || '').toLowerCase();
  renderTickets(1);
}

async function loadTickets(){
    const res = await fetch('/api/tickets');
    if(!res.ok) return;
    allTickets = await res.json();
    renderTickets(1);
}

function renderTickets(page=1){
  currentTicketPage = page;

  // filtr: po numerze pokoju, statusie, powodzie
  let filtered = allTickets.slice();
  if(ticketSearchTerm){
    filtered = filtered.filter(t =>
      (t.room_number && String(t.room_number).toLowerCase().includes(ticketSearchTerm)) ||
      (t.status && t.status.toLowerCase().includes(ticketSearchTerm)) ||
      (t.reason && t.reason.toLowerCase().includes(ticketSearchTerm))
    );
  }

  const start=(page-1)*ticketsPerPage, end=start+ticketsPerPage;
  const rows = filtered.slice(start,end);

  const tbody = document.querySelector('#ticketsTable tbody');
  tbody.innerHTML = '';
  rows.forEach(t=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${t.room_number}</td>
      <td>${t.status}</td>
      <td>${t.created_at || '-'}</td>
      <td>${t.reason || '-'}</td>
      <td>
        <button onclick="openChat(${t.id}, '${(t.reason||'').replace(/'/g, "\\'")}')">Czat</button>
      </td>
    `;
    tbody.appendChild(tr);
  });

  // paginacja
  const pag = document.getElementById('ticketsPagination');
  pag.innerHTML = '';
  const totalPages = Math.ceil(filtered.length / ticketsPerPage);
  for(let i=1;i<=totalPages;i++){
    const b = document.createElement('button');
    b.textContent = i;
    b.className = i===currentTicketPage ? 'pageBtn active' : 'pageBtn';
    b.onclick = ()=>renderTickets(i);
    pag.appendChild(b);
  }
}

/* ---- czaty (wielookienne, jak w adminie) ---- */
function closeChat(ticketId){
  const el = document.getElementById(`chatSection-${ticketId}`);
  if(el) el.remove();
}

async function openChat(ticketId, reason){
  if(document.getElementById(`chatSection-${ticketId}`)) return;

  const chat = document.createElement('div');
  chat.id = `chatSection-${ticketId}`;
  chat.className = 'chat-window';
  chat.innerHTML = `
    <div class="chat-header">
      <strong>Zgłoszenie: ${reason || '(bez tytułu)'}</strong>
      <button class="close-chat" onclick="closeChat(${ticketId})">✖</button>
    </div>
    <div id="chatWindow-${ticketId}" class="chat-messages"></div>
    <div class="chat-input">
      <input type="text" id="chatMessage-${ticketId}" placeholder="Napisz wiadomość...">
      <button onclick="sendChatMessage(${ticketId})">Wyślij</button>
    </div>
  `;
  document.getElementById('activeChats').appendChild(chat);
  loadChat(ticketId);
}

async function loadChat(ticketId){
  const r = await fetch(`/api/tickets/${ticketId}/messages`);
  if(!r.ok) return;
  const msgs = await r.json();
  const win = document.getElementById(`chatWindow-${ticketId}`);
  win.innerHTML = '';
  msgs.forEach(m=>{
    const isMe = m.sender === currentUsername;
    const div = document.createElement('div');
    div.className = 'message ' + (isMe ? 'sent' : 'received');
    div.innerHTML = `<strong>${isMe ? 'Ty' : m.sender}:</strong> ${m.message}`;
    win.appendChild(div);
  });
  win.scrollTop = win.scrollHeight;
}

async function sendChatMessage(ticketId){
  const inp = document.getElementById(`chatMessage-${ticketId}`);
  const message = (inp.value||'').trim();
  if(!message) return;
  await fetch(`/api/tickets/${ticketId}/messages`,{
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({message})
  });
  inp.value = '';
  loadChat(ticketId);
}

/* ---- badge brudnych pokoi ---- */
async function updateDirtyBadge(){
  try{
    const r = await fetch('/api/rooms');
    if(!r.ok) return;
    const rooms = await r.json();
    const dirtyCount = rooms.filter(x => x.status === 'dirty').length;
    const badge = document.getElementById('dirtyBadge');
    if(!badge) return;
    badge.textContent = dirtyCount;
    badge.classList.remove('hidden'); // pokazuj zawsze, nawet 0
  }catch(e){}
}

/* ---- auto-refresh czatów ---- */
setInterval(()=> {
  // odśwież otwarte okna czatu
  document.querySelectorAll('[id^="chatSection-"]').forEach(el=>{
    const tid = parseInt(el.id.replace('chatSection-',''),10);
    if(tid) loadChat(tid);
  });
}, 2000);

/* ---- init ---- */
(async function init(){
  await loadCurrentUser();
  await loadRooms();
  await updateDirtyBadge();
  await loadRoomsForTicket();
  await loadTickets();
})();
</script>
</body>
</html>
